<?php

/**
 *
 * This file is part of Railt package and has been autogenerated.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 */

declare(strict_types=1);

namespace Railt\Introspection;

use Phplrt\Contracts\Ast\NodeInterface;
use Phplrt\Contracts\Grammar\RuleInterface;
use Phplrt\Contracts\Lexer\TokenInterface;
use Phplrt\Contracts\Parser\Exception\ParserRuntimeExceptionInterface;
use Phplrt\Contracts\Parser\ParserInterface;
use Phplrt\Contracts\Source\ReadableInterface;
use Phplrt\Lexer\Lexer;
use Phplrt\Parser\Builder\BuilderInterface;
use Phplrt\Parser\Parser as Runtime;
use Railt\TypeSystem\Value;

/**
 * Class Parser
 */
class Parser implements ParserInterface, BuilderInterface
{
    /**
     * @var string[]
     */
    private const LEXEMES = [
        'T_BRACKET_OPEN' => '\\[',
        'T_BRACKET_CLOSE' => '\\]',
        'T_BRACE_OPEN' => '{',
        'T_BRACE_CLOSE' => '}',
        'T_COLON' => ':',
        'T_COMMA' => ',',
        'T_FLOAT_EXP' => '\\-?(?:0|[1-9][0-9]*)(?:[eE][\\+\\-]?[0-9]+)',
        'T_FLOAT' => '\\-?(?:0|[1-9][0-9]*)(?:\\.[0-9]+)(?:[eE][\\+\\-]?[0-9]+)?',
        'T_INT' => '\\-?(?:0|[1-9][0-9]*)',
        'T_TRUE' => '(?<=\\b)true\\b',
        'T_FALSE' => '(?<=\\b)false\\b',
        'T_NULL' => '(?<=\\b)null\\b',
        'T_BLOCK_STRING' => '"""((?:\\\\"|(?!""").)*)"""',
        'T_STRING' => '"([^"\\\\]*(?:\\\\.[^"\\\\]*)*)"',
        'T_NAME' => '[a-zA-Z_\\x7f-\\xff][a-zA-Z0-9_\\x7f-\\xff]*',
        'T_WHITESPACE' => '\\s+',
    ];

    /**
     * @var string[]
     */
    private const SKIPS = [
        'T_WHITESPACE',
    ];

    /**
     * @var ParserInterface|Runtime
     */
    private ParserInterface $runtime;

    /**
     * Parser constructor.
     */
    public function __construct()
    {
        $lexer = new Lexer(self::LEXEMES, self::SKIPS);

        $this->runtime = new Runtime($lexer, $this->grammar(), [
            Runtime::CONFIG_AST_BUILDER  => $this,
            Runtime::CONFIG_INITIAL_RULE => 0,
        ]);
    }

    /**
     * @return array|RuleInterface[]
     */
    private function grammar(): array
    {
        return [
            0 => new \Phplrt\Grammar\Concatenation(
                array (
  0 => 1,
),
            ),
            1 => new \Phplrt\Grammar\Alternation(
                array (
  0 => 2,
  1 => 3,
  2 => 4,
  3 => 5,
  4 => 6,
  5 => 7,
  6 => 8,
  7 => 9,
),
            ),
            2 => new \Phplrt\Grammar\Lexeme(
                'T_INT',
                true,
            ),
            3 => new \Phplrt\Grammar\Alternation(
                array (
  0 => 18,
  1 => 19,
),
            ),
            5 => new \Phplrt\Grammar\Alternation(
                array (
  0 => 10,
  1 => 11,
),
            ),
            6 => new \Phplrt\Grammar\Lexeme(
                'T_NULL',
                true,
            ),
            7 => new \Phplrt\Grammar\Lexeme(
                'T_NAME',
                true,
            ),
            8 => new \Phplrt\Grammar\Concatenation(
                array (
  0 => 15,
  1 => 16,
  2 => 17,
),
            ),
            9 => new \Phplrt\Grammar\Concatenation(
                array (
  0 => 21,
  1 => 22,
  2 => 23,
),
            ),
            10 => new \Phplrt\Grammar\Lexeme(
                'T_FALSE',
                true,
            ),
            11 => new \Phplrt\Grammar\Lexeme(
                'T_TRUE',
                true,
            ),
            12 => new \Phplrt\Grammar\Lexeme(
                'T_COMMA',
                false,
            ),
            13 => new \Phplrt\Grammar\Optional(
                12,
            ),
            14 => new \Phplrt\Grammar\Concatenation(
                array (
  0 => 1,
  1 => 13,
),
            ),
            15 => new \Phplrt\Grammar\Lexeme(
                'T_BRACKET_OPEN',
                false,
            ),
            16 => new \Phplrt\Grammar\Repetition(
                14,
                0,
                INF,
            ),
            17 => new \Phplrt\Grammar\Lexeme(
                'T_BRACKET_CLOSE',
                false,
            ),
            18 => new \Phplrt\Grammar\Lexeme(
                'T_FLOAT',
                true,
            ),
            19 => new \Phplrt\Grammar\Lexeme(
                'T_FLOAT_EXP',
                true,
            ),
            21 => new \Phplrt\Grammar\Lexeme(
                'T_BRACE_OPEN',
                false,
            ),
            22 => new \Phplrt\Grammar\Repetition(
                20,
                0,
                INF,
            ),
            23 => new \Phplrt\Grammar\Lexeme(
                'T_BRACE_CLOSE',
                false,
            ),
            24 => new \Phplrt\Grammar\Lexeme(
                'T_COMMA',
                false,
            ),
            25 => new \Phplrt\Grammar\Lexeme(
                'T_NAME',
                true,
            ),
            26 => new \Phplrt\Grammar\Lexeme(
                'T_COLON',
                false,
            ),
            27 => new \Phplrt\Grammar\Optional(
                24,
            ),
            20 => new \Phplrt\Grammar\Concatenation(
                array (
  0 => 25,
  1 => 26,
  2 => 1,
  3 => 27,
),
            ),
            4 => new \Phplrt\Grammar\Alternation(
                array (
  0 => 28,
  1 => 29,
),
            ),
            28 => new \Phplrt\Grammar\Lexeme(
                'T_BLOCK_STRING',
                true,
            ),
            29 => new \Phplrt\Grammar\Lexeme(
                'T_STRING',
                true,
            ),
        ];
    }

    /**
     * @param ReadableInterface $file
     * @param RuleInterface $rule
     * @param TokenInterface $token
     * @param int|string $state
     * @param array|iterable|NodeInterface|TokenInterface $children
     * @return mixed|null
     */
    public function build(ReadableInterface $file, RuleInterface $rule, TokenInterface $token, $state, $children)
    {
        switch ($state) {
            case 0:
                return [$children];
            case 5:
                return Value\BooleanValue::parse($children->getName() === 'T_TRUE');
            case 7:
                return Value\EnumValue::parse($children->getValue());
            case 8:
                return Value\ListValue::parse($children);
            case 6:
                return Value\NullValue::parse(null);
            case 2:
                return Value\IntValue::parse($children->getValue());
            case 3:
                return Value\FloatValue::parse($children->getValue());
            case 9:
                $result = [];

    for ($i = 0, $count = \count((array)$children); $i < $count; $i += 2) {
        $result[$children[$i]->getValue()] = $children[$i + 1];
    }

    return Value\InputObjectValue::parse($result);
            case 28:
                return Value\StringValue::parse(\substr($children->getValue(), 3, -3));
            case 29:
                return Value\StringValue::parse(\substr($children->getValue(), 1, -1));
        }

        return null;
    }

    /**
     * @param ReadableInterface|resource|string $source
     * @return iterable
     * @throws ParserRuntimeExceptionInterface
     * @throws \Throwable
     */
    public function parse($source): iterable
    {
        return $this->runtime->parse($source);
    }
}
